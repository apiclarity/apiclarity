// Package common provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.1-0.20220609223533-7da811e1cf30 DO NOT EDIT.
package common

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for APIClarityFeatureEnum.
const (
	Bfla              APIClarityFeatureEnum = "bfla"
	Fuzzer            APIClarityFeatureEnum = "fuzzer"
	SpecDiffer        APIClarityFeatureEnum = "spec_differ"
	Specdiffs         APIClarityFeatureEnum = "specdiffs"
	Specreconstructor APIClarityFeatureEnum = "specreconstructor"
	Traceanalyzer     APIClarityFeatureEnum = "traceanalyzer"
)

// Defines values for APIGatewayType.
const (
	APIGEEX APIGatewayType = "APIGEEX"
	KONG    APIGatewayType = "KONG"
	TYK     APIGatewayType = "TYK"
)

// Defines values for AlertSeverityEnum.
const (
	ALERTCRITICAL AlertSeverityEnum = "ALERT_CRITICAL"
	ALERTINFO     AlertSeverityEnum = "ALERT_INFO"
	ALERTWARN     AlertSeverityEnum = "ALERT_WARN"
)

// Defines values for ApiEventSortKey.
const (
	ApiType         ApiEventSortKey = "apiType"
	DestinationIP   ApiEventSortKey = "destinationIP"
	DestinationPort ApiEventSortKey = "destinationPort"
	HostSpecName    ApiEventSortKey = "hostSpecName"
	Method          ApiEventSortKey = "method"
	Path            ApiEventSortKey = "path"
	SourceIP        ApiEventSortKey = "sourceIP"
	SpecDiffType    ApiEventSortKey = "specDiffType"
	StatusCode      ApiEventSortKey = "statusCode"
	Time            ApiEventSortKey = "time"
)

// Defines values for ApiInventorySortKey.
const (
	HasProvidedSpec      ApiInventorySortKey = "hasProvidedSpec"
	HasReconstructedSpec ApiInventorySortKey = "hasReconstructedSpec"
	Name                 ApiInventorySortKey = "name"
	Port                 ApiInventorySortKey = "port"
)

// Defines values for ApiTypeEnum.
const (
	EXTERNAL ApiTypeEnum = "EXTERNAL"
	INTERNAL ApiTypeEnum = "INTERNAL"
)

// Defines values for DiffType.
const (
	GENERALDIFF DiffType = "GENERAL_DIFF"
	NODIFF      DiffType = "NO_DIFF"
	SHADOWDIFF  DiffType = "SHADOW_DIFF"
	ZOMBIEDIFF  DiffType = "ZOMBIE_DIFF"
)

// Defines values for HttpMethod.
const (
	CONNECT HttpMethod = "CONNECT"
	DELETE  HttpMethod = "DELETE"
	GET     HttpMethod = "GET"
	HEAD    HttpMethod = "HEAD"
	OPTIONS HttpMethod = "OPTIONS"
	PATCH   HttpMethod = "PATCH"
	POST    HttpMethod = "POST"
	PUT     HttpMethod = "PUT"
	TRACE   HttpMethod = "TRACE"
)

// Defines values for Severity.
const (
	CRITICAL Severity = "CRITICAL"
	HIGH     Severity = "HIGH"
	INFO     Severity = "INFO"
	LOW      Severity = "LOW"
	MEDIUM   Severity = "MEDIUM"
)

// Defines values for SpecType.
const (
	NONE          SpecType = "NONE"
	PROVIDED      SpecType = "PROVIDED"
	RECONSTRUCTED SpecType = "RECONSTRUCTED"
)

// Description of APIClarity feature and the list of API hosts (in the form 'host:port') the feature requires to get trace for
type APIClarityFeature struct {
	// Short human readable description of the feature
	FeatureDescription *string `json:"featureDescription,omitempty"`

	// APIClarity Feature Name
	FeatureName  APIClarityFeatureEnum `json:"featureName"`
	HostsToTrace *[]string             `json:"hostsToTrace,omitempty"`
}

// APIClarity Feature Name
type APIClarityFeatureEnum string

// List of APIClarity features and for each feature the list of API hosts (in the form 'host:port') the feature requires to get trace for
type APIClarityFeatureList struct {
	Features *[]APIClarityFeature `json:"features,omitempty"`
}

// An API Finding
type APIFinding struct {
	// Could be any opaque JSON object
	AdditionalInfo *map[string]interface{} `json:"additional_info,omitempty"`

	// Human readable description of the finding
	Description string `json:"description"`

	// Human readable name of the finding
	Name string `json:"name"`

	// JSON pointer to the location of the finding in the specification. See https://datatracker.ietf.org/doc/html/rfc6901. If at the time of creation of the finding, there is no specification, then this field is an empty string.
	ProvidedSpecLocation *string `json:"provided_spec_location,omitempty"`

	// JSON pointer to the location of the finding in the specification. See https://datatracker.ietf.org/doc/html/rfc6901. If at the time of creation of the finding, there is no specification, then this field is an empty string.
	ReconstructedSpecLocation *string `json:"reconstructed_spec_location,omitempty"`

	// Severity of a finding
	Severity Severity `json:"severity"`

	// Name of the module which created this finding
	Source string `json:"source"`

	// Type of the finding
	Type string `json:"type"`
}

// A group of findings
type APIFindings struct {
	// A list of findings
	Items *[]APIFinding `json:"items,omitempty"`
}

// Gateway which is externally exposing APIs
type APIGateway struct {
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`

	// Unique name identifying a gateway
	Name  string         `json:"name"`
	Token *[]byte        `json:"token,omitempty"`
	Type  APIGatewayType `json:"type"`
}

// APIGatewayType defines model for APIGatewayType.
type APIGatewayType string

// AlertSeverityEnum defines model for AlertSeverityEnum.
type AlertSeverityEnum string

// ApiCount defines model for ApiCount.
type ApiCount struct {
	ApiHostName *string `json:"apiHostName,omitempty"`

	// hold the relevant api info id
	ApiInfoId *uint32      `json:"apiInfoId,omitempty"`
	ApiPort   *int         `json:"apiPort,omitempty"`
	ApiType   *ApiTypeEnum `json:"apiType,omitempty"`
	NumCalls  *int         `json:"numCalls,omitempty"`
}

// ApiEvent defines model for ApiEvent.
type ApiEvent struct {
	Alerts *[]ModuleAlert `json:"alerts,omitempty"`

	// hold the relevant api spec info id
	ApiInfoId                *uint32      `json:"apiInfoId,omitempty"`
	ApiType                  *ApiTypeEnum `json:"apiType,omitempty"`
	DestinationIP            *string      `json:"destinationIP,omitempty"`
	DestinationPort          *int         `json:"destinationPort,omitempty"`
	HasProvidedSpecDiff      *bool        `json:"hasProvidedSpecDiff,omitempty"`
	HasReconstructedSpecDiff *bool        `json:"hasReconstructedSpecDiff,omitempty"`
	HostSpecName             *string      `json:"hostSpecName,omitempty"`
	Id                       *uint32      `json:"id,omitempty"`
	Method                   *HttpMethod  `json:"method,omitempty"`
	Path                     *string      `json:"path,omitempty"`
	Query                    *string      `json:"query,omitempty"`
	RequestTime              *time.Time   `json:"requestTime,omitempty"`
	SourceIP                 *string      `json:"sourceIP,omitempty"`
	SpecDiffType             *DiffType    `json:"specDiffType,omitempty"`
	StatusCode               *int         `json:"statusCode,omitempty"`
	Time                     *time.Time   `json:"time,omitempty"`
}

// ApiEventPathAndMethods defines model for ApiEventPathAndMethods.
type ApiEventPathAndMethods struct {
	Methods *[]HttpMethod `json:"methods,omitempty"`
	Path    *string       `json:"path,omitempty"`
}

// ApiEventSortKey defines model for ApiEventSortKey.
type ApiEventSortKey string

// ApiEventSpecDiff defines model for ApiEventSpecDiff.
type ApiEventSpecDiff struct {
	DiffType *DiffType `json:"diffType,omitempty"`

	// New spec json string
	NewSpec string `json:"newSpec"`

	// Old spec json string
	OldSpec string `json:"oldSpec"`
}

// ApiFindingsNotification defines model for ApiFindingsNotification.
type ApiFindingsNotification struct {
	// A list of findings
	Items            *[]APIFinding `json:"items,omitempty"`
	NotificationType string        `json:"notificationType"`
}

// ApiID defines model for ApiID.
type ApiID = int64

// ApiInfo defines model for ApiInfo.
type ApiInfo struct {
	// String representing the entity which created this API. APICLARITY means it has been created by APIClarity on first trace
	CreatedBy            *string `json:"createdBy,omitempty"`
	DestinationNamespace *string `json:"destinationNamespace,omitempty"`
	HasProvidedSpec      *bool   `json:"hasProvidedSpec,omitempty"`
	HasReconstructedSpec *bool   `json:"hasReconstructedSpec,omitempty"`
	Id                   *uint32 `json:"id,omitempty"`

	// API name
	Name *string `json:"name,omitempty"`
	Port *int    `json:"port,omitempty"`
}

// ApiInfoWithType defines model for ApiInfoWithType.
type ApiInfoWithType struct {
	ApiType *ApiTypeEnum `json:"apiType,omitempty"`

	// String representing the entity which created this API. APICLARITY means it has been created by APIClarity on first trace
	CreatedBy            *string `json:"createdBy,omitempty"`
	DestinationNamespace *string `json:"destinationNamespace,omitempty"`
	HasProvidedSpec      *bool   `json:"hasProvidedSpec,omitempty"`
	HasReconstructedSpec *bool   `json:"hasReconstructedSpec,omitempty"`
	Id                   *uint32 `json:"id,omitempty"`

	// API name
	Name *string `json:"name,omitempty"`
	Port *int    `json:"port,omitempty"`
}

// ApiInventorySortKey defines model for ApiInventorySortKey.
type ApiInventorySortKey string

// An object that is returned in all cases of failures
type ApiResponse struct {
	Message string `json:"message"`
}

// ApiTypeEnum defines model for ApiTypeEnum.
type ApiTypeEnum string

// ApiUsage defines model for ApiUsage.
type ApiUsage struct {
	NumOfCalls *int       `json:"numOfCalls"`
	Time       *time.Time `json:"time,omitempty"`
}

// ApiUsages defines model for ApiUsages.
type ApiUsages struct {
	ApisWithDiff *[]ApiUsage `json:"apisWithDiff,omitempty"`
	ExistingApis *[]ApiUsage `json:"existingApis,omitempty"`
	NewApis      *[]ApiUsage `json:"newApis,omitempty"`
}

// ApprovedReview defines model for ApprovedReview.
type ApprovedReview struct {
	ReviewPathItems *[]ReviewPathItem `json:"reviewPathItems,omitempty"`
}

// Base Notification all APIClarity notifications must extend
type BaseNotification struct {
	NotificationType string `json:"notificationType"`
}

// DiffType defines model for DiffType.
type DiffType string

// HitCount defines model for HitCount.
type HitCount struct {
	Count *int64     `json:"count"`
	Time  *time.Time `json:"time,omitempty"`
}

// HttpMethod defines model for HttpMethod.
type HttpMethod string

// MethodAndPath defines model for MethodAndPath.
type MethodAndPath struct {
	Method *HttpMethod         `json:"method,omitempty"`
	Path   *string             `json:"path,omitempty"`
	PathId *openapi_types.UUID `json:"pathId,omitempty"`
}

// ModuleAlert defines model for ModuleAlert.
type ModuleAlert struct {
	Alert *AlertSeverityEnum `json:"alert,omitempty"`

	// Name of the module which created this alert
	ModuleName *string `json:"moduleName,omitempty"`

	// Optional description of reason of the alert
	Reason *string `json:"reason,omitempty"`
}

// ModuleVersion defines model for ModuleVersion.
type ModuleVersion struct {
	Version string `json:"version"`
}

// An object representing the provided and reconstructed API specs
type OpenApiSpecs struct {
	// An object containing info about a spec
	ProvidedSpec *SpecInfo `json:"providedSpec,omitempty"`

	// An object containing info about a spec
	ReconstructedSpec *SpecInfo `json:"reconstructedSpec,omitempty"`
}

// ReviewPathItem defines model for ReviewPathItem.
type ReviewPathItem struct {
	// Group of api event paths (original) that suggestedPath is representing
	ApiEventsPaths *[]ApiEventPathAndMethods `json:"apiEventsPaths,omitempty"`

	// Represents the parameterized path suggested by the engine
	SuggestedPath *string `json:"suggestedPath,omitempty"`
}

// Severity of a finding
type Severity string

// SpecDiffTime defines model for SpecDiffTime.
type SpecDiffTime struct {
	ApiEventId  *uint32    `json:"apiEventId,omitempty"`
	ApiHostName *string    `json:"apiHostName,omitempty"`
	DiffType    *DiffType  `json:"diffType,omitempty"`
	Time        *time.Time `json:"time,omitempty"`
}

// An object containing info about a spec
type SpecInfo struct {
	Tags *[]SpecTag `json:"tags,omitempty"`
}

// SpecTag defines model for SpecTag.
type SpecTag struct {
	Description       *string          `json:"description,omitempty"`
	MethodAndPathList *[]MethodAndPath `json:"methodAndPathList,omitempty"`
	Name              *string          `json:"name,omitempty"`
}

// SpecType defines model for SpecType.
type SpecType string

// An object that is return in cases of success that return nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// SuggestedReview defines model for SuggestedReview.
type SuggestedReview struct {
	Id              *uint32           `json:"id,omitempty"`
	ReviewPathItems *[]ReviewPathItem `json:"reviewPathItems,omitempty"`
}

// spec in json or yaml format
type RawSpec struct {
	// spec in json or yaml format
	RawSpec *string `json:"rawSpec,omitempty"`
}

// Sensitive defines model for Sensitive.
type Sensitive = bool

// ServerInterface represents all server handlers.
type ServerInterface interface {
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
